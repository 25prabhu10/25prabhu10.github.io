import{f as e,h as t,j as n,t as r}from"./chunks/plugin-vue_export-helper.CMCX8Lry.js";const i=JSON.parse(`{"title":"Domain Driven Design","description":"Build software by modeling it around the business domain","frontmatter":{"title":"Domain Driven Design","description":"Build software by modeling it around the business domain"},"headers":[],"relativePath":"Concepts/Designs/System_Designs/Domain_Driven_Design.md","filePath":"Concepts/Designs/System_Designs/Domain_Driven_Design.md","lastUpdated":1767053997000}`);var a={name:`Concepts/Designs/System_Designs/Domain_Driven_Design.md`};function o(r,i,a,o,s,c){return n(),e(`div`,null,[...i[0]||=[t(`<h1 id="domain-driven-design" tabindex="-1">Domain Driven Design <a class="header-anchor" href="#domain-driven-design" aria-label="Permalink to “Domain Driven Design”">​</a></h1><p>Domain-Driven Design (DDD) is a software development approach that focuses on building software that closely aligns with a particular business domain. It is an approach to software development that emphasizes collaboration between technical experts and domain experts to create a shared understanding of the problem space and build a model that accurately represents the domain</p><ul><li><strong>Domain</strong>: The problem space you&#39;re trying to address</li><li><strong>Entities</strong>: Objects that have a distinct identity and life-cycle</li><li><strong>Value Objects</strong>: Objects that are defined only by their attributes and do not have a distinct identity</li><li><strong>Aggregates</strong>: Groups of related entities and value objects that are treated as a single unit. Each aggregate has a root entity (aggregate root) that ensures the integrity of the aggregate</li><li><strong>Repositories</strong>: Interfaces that provide methods for accessing aggregates from a data store</li><li><strong>Services</strong>: Business logic that doesn&#39;t naturally fit within an entity or value object</li><li><strong>Modules</strong>: Logical grouping of related concepts to keep the system organized <blockquote><p>Any fool can write code that a computer can understand. Good programmers write code that humans can understand</p><p>Refactoring: Improving the Design of Existing Code, 1999</p></blockquote></li></ul><p>Here are the key ideas behind DDD:</p><ul><li><p><strong>Domain Model:</strong> DDD emphasizes creating a domain model, essentially a blueprint of a specific business area&#39;s core concepts and processes. This model bridges the gap between the technical world of software and the real-world business domain</p></li><li><p><strong>Ubiquitous Language:</strong> A core principle of DDD is establishing a &quot;ubiquitous language&quot; - a common vocabulary shared by developers and business experts. This shared language ensures that everyone involved understands the terminology and concepts used in the system</p></li><li><p><strong>Bounded Contexts:</strong> DDD acknowledges that complex systems cannot be modelled simultaneously. Instead, it advocates dividing the system into smaller, bounded contexts, each with its focused domain model. This promotes modularity and maintainability</p></li><li><p><strong>Tactical Patterns:</strong> DDD offers a variety of patterns for modelling different aspects of the domain. These patterns include <em>Entities</em> (objects with a unique identity), <em>Value Objects</em> (objects that hold data), <em>Aggregates</em> (groups of related entities), and <em>Domain Services</em> (reusable logic specific to the domain)</p></li></ul><p>Overall, DDD aims to create software that is functional and reflects the specific needs and terminology of the business domain it serves. This can lead to improved communication, maintainability, and long-term flexibility of the software</p><h2 id="the-ubiquitous-language" tabindex="-1">The Ubiquitous Language <a class="header-anchor" href="#the-ubiquitous-language" aria-label="Permalink to “The Ubiquitous Language”">​</a></h2><p>A common language for domain experts and technical team members to ensure clear communication and shared understanding of the domain concepts</p><h2 id="tactical-patterns" tabindex="-1">Tactical Patterns <a class="header-anchor" href="#tactical-patterns" aria-label="Permalink to “Tactical Patterns”">​</a></h2><p>A set of building blocks to structure the implementation of a model according to best practices&quot; <em>Entity</em>, <em>Aggregate</em>, <em>Value Object</em>, <em>Domain Service</em>, <em>Domain Event</em>, <em>Repository</em>, <em>Factory</em>, <em>Module</em>, etc...</p><h2 id="references" tabindex="-1">References <a class="header-anchor" href="#references" aria-label="Permalink to “References”">​</a></h2><ul><li>Domain-Driven Design: Tackling Complexity in the Heart of Software (2003) - Eric Evans (Author)</li><li><a href="https://github.com/Sairyss/domain-driven-hexagon" target="_blank" rel="noreferrer">Sairyss/domain-driven-hexagon - GitHub</a></li><li><a href="https://github.com/balkrish33/Books" target="_blank" rel="noreferrer">Books</a></li></ul>`,12)]])}var s=r(a,[[`render`,o]]);export{i as __pageData,s as default};