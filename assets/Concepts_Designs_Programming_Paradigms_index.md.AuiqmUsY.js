import{A as e,d as t,m as n}from"./chunks/runtime-core.esm-bundler.BXAIOQQS.js";import{t as r}from"./chunks/plugin-vue_export-helper.CtN8rQnz.js";const i=JSON.parse(`{"title":"Programming Paradigms","description":"","frontmatter":{"title":"Programming Paradigms","next":"./Object-Oriented_Programming.md","sidebar":false},"headers":[],"relativePath":"Concepts/Designs/Programming_Paradigms/index.md","filePath":"Concepts/Designs/Programming_Paradigms/README.md","lastUpdated":1756574703000}`);var a={name:`Concepts/Designs/Programming_Paradigms/index.md`};function o(r,i,a,o,s,c){return e(),t(`div`,null,[...i[0]||=[n(`<h1 id="programming-paradigms" tabindex="-1">Programming Paradigms <a class="header-anchor" href="#programming-paradigms" aria-label="Permalink to “Programming Paradigms”">​</a></h1><p>A programming paradigm is a style of programming, a way of thinking about software construction based on some fundamental, defining principles. There are several programming paradigms, each with its own strengths and weaknesses. The term programming paradigm may also be used to refer to a single programming language</p><p>Common Programming paradigms:</p><ol><li><p><strong>Imperative</strong>: in which the programmer instructs the machine how to change its state</p><ol><li><p>Procedural Programming: which groups instructions into procedures</p><ul><li>Languages: C, Pascal, Fortran, COBOL, ALGOL, PL/I, Ada, Modula-2, Oberon, Oberon-2, Component Pascal, Object Pascal, Turbo Pascal, Delphi, Free Pascal, Visual</li></ul></li><li><p><a href="./Object-Oriented_Programming.html">Object-Oriented Programming</a>: which groups instructions with the part of the state they operate on</p><ul><li>Languages: Java, C++, C#, Python, Ruby, Swift, Objective-C, Kotlin, Scala, PHP, JavaScript, TypeScript, Dart, Visual Basic, Delphi, Eiffel, Smalltalk, Simula, Self, Newspeak, ABAP, Ada, COBOL, Fortran, RPG, PL/I, Object Pascal, Clarion, ColdFusion, PowerBuilder, Progress, Realbasic, Real Studio, Visual FoxPro, Visual DataFlex, Visual Objects, Xojo</li></ul></li></ol></li><li><p><strong>Declarative</strong>: in which the programmer merely declares properties of the desired result, but not how to compute it</p><ol><li><p><a href="./Functional_Programming.html">Functional Programming</a>: in which the desired result is declared as the value of a series of function applications</p><ul><li>Languages: Haskell, Lisp, Scheme, ML, Scala, Clojure, F#, Erlang, Elixir, Elm, OCaml, Racket, PureScript, Idris, Agda, Coq, ReasonML</li></ul></li><li><p>Logic: in which the desired result is declared as the answer to a question about a system of facts and rules</p><ul><li>Languages: Prolog</li></ul></li><li><p>Mathematical: in which the desired result is declared as the solution of an optimization problem</p></li><li><p>Reactive: in which the desired result is declared with data streams and the propagation of change</p></li></ol></li></ol>`,4)]])}var s=r(a,[[`render`,o]]);export{i as __pageData,s as default};