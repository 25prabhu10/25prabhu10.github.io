import{f as e,h as t,j as n,t as r}from"./chunks/plugin-vue_export-helper.CMCX8Lry.js";const i=JSON.parse(`{"title":"Tree","description":"Tree","frontmatter":{"title":"Tree","description":"Tree"},"headers":[],"relativePath":"Concepts/Data-Structures_and_Algorithms/Data-Structures/Trees.md","filePath":"Concepts/Data-Structures_and_Algorithms/Data-Structures/Trees.md","lastUpdated":1767053997000}`);var a={name:`Concepts/Data-Structures_and_Algorithms/Data-Structures/Trees.md`};function o(r,i,a,o,s,c){return n(),e(`div`,null,[...i[0]||=[t(`<h1 id="tree" tabindex="-1">Tree <a class="header-anchor" href="#tree" aria-label="Permalink to “Tree”">​</a></h1><p>A tree is a widely used abstract data type (ADT) that represents a hierarchical tree structure with a set of connected nodes</p><p>Subcategories:</p><ul><li><a href="#binary-tree">Binary trees</a></li><li>Decision trees</li><li><a href="./Heap.html">Heaps</a> (data structures)</li><li>R-tree</li><li>Search trees</li></ul><h2 id="terminology" tabindex="-1">Terminology <a class="header-anchor" href="#terminology" aria-label="Permalink to “Terminology”">​</a></h2><ol><li><p><strong>Node</strong>: A structure which may contain data and connections to other nodes, sometimes called <strong>edges</strong> or <strong>links</strong></p></li><li><p><strong>Child</strong>: Each node in a tree has zero or more <strong>child nodes</strong></p></li><li><p><strong>Parent</strong>: A node that has a child</p></li><li><p><strong>Root</strong>: All nodes have exactly one parent, except the topmost <strong>root node</strong></p></li><li><p><strong>Neighbor</strong>: Parent or child</p></li><li><p><strong>Ancestors</strong>: A node might have many <strong>ancestor nodes</strong>, such as the parent&#39;s parent</p><ul><li>A node reachable by repeated proceeding from child to parent</li></ul></li><li><p><strong>Descendants</strong>: A node reachable by repeated proceeding from parent to child. Also known as <strong>subchild</strong></p></li><li><p><strong>Siblings</strong>: Child nodes with the same parent</p></li><li><p><strong>Internal node</strong>: Any node of a tree <strong>that has child nodes</strong> (also known as an <em>inner node</em>, <em>inode</em> for short, or <em>branch node</em>)</p></li><li><p><strong>External node</strong>: Any node that <strong>does not have child nodes</strong> (also known as an <em>outer node</em>, <strong>leaf node</strong>, or <em>terminal node</em>)</p></li><li><p><strong>Degree</strong>: For a given node, its number of children. A leaf has necessarily degree zero</p></li><li><p><strong>Degree of tree</strong>: The degree of a tree is the maximum degree of a node in the tree</p></li><li><p><strong>Distance</strong>: The number of edges along the shortest path between two nodes</p></li><li><p><strong>Height</strong>: The height of a node is the length of the longest downward path to a leaf from that node</p></li><li><p><strong>Depth</strong>: The depth of a node is the length of the path to its root</p></li><li><p><strong>Levels</strong>: The level of a node is the number of edges along the unique path between it and the root node</p><ul><li>This is the same as depth when using zero-based counting</li></ul></li><li><p><strong>Width</strong>: The number of nodes in a level</p></li><li><p><strong>Forest</strong>: A set of one or more disjoint trees</p></li><li><p><strong>Breadth</strong>: The number of leaves</p></li><li><p><strong>Size of a tree</strong>: Number of nodes in the tree</p></li><li><p><strong>Subtree</strong>: Each non-root node can be treated as the root node of its own subtree</p></li></ol><h2 id="binary-tree" tabindex="-1">Binary Tree <a class="header-anchor" href="#binary-tree" aria-label="Permalink to “Binary Tree”">​</a></h2><p>A Binary Tree is a tree with degree of node <em>2</em></p><ul><li>Every node can have a maximum 2 children</li><li>It can have <strong>0, 1, or 2 children</strong></li></ul><h3 id="number-of-binary-tress" tabindex="-1">Number Of Binary Tress <a class="header-anchor" href="#number-of-binary-tress" aria-label="Permalink to “Number Of Binary Tress”">​</a></h3><ol><li><p>For Unnamed Nodes the number of Binary Tress that can be generated using <code>n</code> Node is calculated using <em>Catalan Number</em>:</p><ul><li><p><code>T(n) = (2nCn)/(n + 1)</code></p><ul><li><code>T(3) = 5</code></li><li><code>T(4) = 14</code></li><li><code>T(5) = 42</code></li></ul></li><li><p><code>T(n) = [(i=1) SUMATION n] T(i - 1) * T(n - i)</code></p></li><li><p>Number of Binary Tress with Max height containing <code>n</code> Node: <code>2^n-1</code></p></li></ul></li><li><p>For Named Nodes the number of Binary Tress that can be generated using <code>n</code> Node is calculated using:</p><ul><li><code>T(n) = ((2nCn)/(n + 1)) * n!</code></li></ul></li></ol><h3 id="height-vs-nodes-of-binary-tree" tabindex="-1">Height vs Nodes Of Binary Tree <a class="header-anchor" href="#height-vs-nodes-of-binary-tree" aria-label="Permalink to “Height vs Nodes Of Binary Tree”">​</a></h3><ul><li><p>For Height <code>h</code> the:</p><ul><li>Min number of Nodes required: <code>min(n) = h + 1</code></li><li>Max number of Nodes required: <code>max(n) = 2^(h + 1) - 1</code> (Sum of G-P Series with <code>a=1</code> and <code>r=2</code>)</li></ul></li><li><p>For <code>n</code> Nodes the:</p><ul><li>Min Height: <code>min(n) = (log2 (n + 1)) - 1</code></li><li>Max Height: <code>max(h) = n - 1</code></li></ul></li><li><p>Relation between Degrees:</p><ul><li><code>deg(0) = deg(2) + 1</code></li></ul></li></ul><h3 id="strict-proper-complete-binary-tree" tabindex="-1">Strict / Proper / Complete Binary Tree <a class="header-anchor" href="#strict-proper-complete-binary-tree" aria-label="Permalink to “Strict / Proper / Complete Binary Tree”">​</a></h3><p>A Binary Tree is a Strict Binary Tree if every node has either degree 0 or 2. Should not contain nodes with degree 1 (node with 1 child).</p><h3 id="height-vs-nodes" tabindex="-1">Height vs Nodes <a class="header-anchor" href="#height-vs-nodes" aria-label="Permalink to “Height vs Nodes”">​</a></h3><ul><li><p>For Height <code>h</code> the:</p><ul><li>Min number of Nodes required: <code>min(n) = (2 * h) + 1</code></li><li>Max number of Nodes required: <code>max(n) = 2^(h + 1) - 1</code> (Sum of G-P Series with <code>a=1</code> and <code>r=2</code>)</li></ul></li><li><p>For <code>n</code> Nodes the:</p><ul><li>Min Height: <code>min(h) = (log2 (n + 1)) - 1</code></li><li>Max Height: <code>max(h) = (n - 1)/2</code></li></ul></li><li><p>External Binary Nodes to Internal Binary Nodes: <code>e = i + 1</code></p></li></ul><h3 id="array-representation" tabindex="-1">Array Representation <a class="header-anchor" href="#array-representation" aria-label="Permalink to “Array Representation”">​</a></h3><h3 id="linked-list-representation" tabindex="-1">Linked List Representation <a class="header-anchor" href="#linked-list-representation" aria-label="Permalink to “Linked List Representation”">​</a></h3><h3 id="full-vs-complete-binary-tree" tabindex="-1">Full vs Complete Binary Tree <a class="header-anchor" href="#full-vs-complete-binary-tree" aria-label="Permalink to “Full vs Complete Binary Tree”">​</a></h3><h3 id="strict-vs-complete-binary-tree" tabindex="-1">Strict vs Complete Binary Tree <a class="header-anchor" href="#strict-vs-complete-binary-tree" aria-label="Permalink to “Strict vs Complete Binary Tree”">​</a></h3><h2 id="tree-traversal" tabindex="-1">Tree Traversal <a class="header-anchor" href="#tree-traversal" aria-label="Permalink to “Tree Traversal”">​</a></h2><p>Tree traversing means visiting all the nodes</p><ol><li><p>Pre-order (VLR):</p><ul><li>Visit (node)</li><li>Pre-order (left sub-tree)</li><li>Pre-order (right sub-tree)</li></ul></li><li><p>In-order (LVR):</p><ul><li>In-order (left sub-tree)</li><li>Visit (node)</li><li>In-order (right sub-tree)</li></ul></li><li><p>Post-order (LRV):</p><ul><li>Post-order (left sub-tree)</li><li>Post-order (right sub-tree)</li><li>Visit (node)</li></ul></li><li><p>Level-Order: Level by Level</p></li></ol><p>Generating Tree if Traversal is provided:</p><ol><li><p>If only Pre-order or In-order or Post-order is provided: Not possible to reproduce</p></li><li><p>If only Pre-order and Post-order are provided: Not possible to reproduce</p></li><li><p>If only Pre-order and In-order or Post-order and In-order are provided: It is <strong>possible to reproduce</strong></p></li></ol><h2 id="binary-search-tree-bst" tabindex="-1">Binary Search Tree (BST) <a class="header-anchor" href="#binary-search-tree-bst" aria-label="Permalink to “Binary Search Tree (BST)”">​</a></h2><ul><li>No Duplicates</li><li>In-order Traversal will give sorted order</li><li>Number of BST for <code>n</code> nodes: <code>(2nCn)/(n+1)</code></li><li>Usually represented using Doubly Linked List</li><li>In-Order traversal is preferred</li></ul><p>Drawbacks of Binary Search Tree:</p><ul><li><p>No control over the height of the BST as it depends on the order of input</p></li><li><p>It can become unbalanced easily</p></li></ul><h2 id="avl-tree" tabindex="-1">AVL Tree <a class="header-anchor" href="#avl-tree" aria-label="Permalink to “AVL Tree”">​</a></h2><p>Height balanced Binary Search Tress</p><p>It uses balance factor to balance the height:</p><ul><li>balance factor = height of left subtree - height of right subtree</li><li>Balance factor is calculated at each node</li><li>The balance factor must be any one of these: <code>{ -1, 0 1 }</code></li><li><code>bf = |hl - hr| &lt;= 1</code> it is balanced</li><li>If <code>bf = |hl - hr| &gt; 1</code> then it is imbalanced</li></ul><h3 id="rotations-at-the-time-on-insertion" tabindex="-1">Rotations At the time on insertion <a class="header-anchor" href="#rotations-at-the-time-on-insertion" aria-label="Permalink to “Rotations At the time on insertion”">​</a></h3><ol><li>LL - Rotation</li><li>RR - Rotation</li><li>LR - Rotation</li><li>RL - Rotation</li></ol><h3 id="generating-avl-tree" tabindex="-1">Generating AVL Tree <a class="header-anchor" href="#generating-avl-tree" aria-label="Permalink to “Generating AVL Tree”">​</a></h3><h3 id="deletion" tabindex="-1">Deletion <a class="header-anchor" href="#deletion" aria-label="Permalink to “Deletion”">​</a></h3><ol><li>L1 - Rotation --&gt; (LL Rotation)</li><li>L-1 - Rotation --&gt; (LR Rotation)</li><li>L0 - Rotation --&gt; (LL or LR Rotation)</li><li>R1 - Rotation --&gt; (RR Rotation)</li><li>R-1 - Rotation --&gt; (RL Rotation)</li><li>R0 - Rotation --&gt; (RR or RL Rotation)</li></ol><h3 id="height-vs-nodes-of-avl-tree" tabindex="-1">Height vs Nodes of AVL Tree <a class="header-anchor" href="#height-vs-nodes-of-avl-tree" aria-label="Permalink to “Height vs Nodes of AVL Tree”">​</a></h3><ul><li><p>For Height <code>h</code> the if <code>h</code> starts from 1:</p><ul><li><p>Min number of Nodes required: (Fibonacci Series)</p><ul><li>For 0: 0</li><li>For 1: 1</li><li>For &gt;1: <code>min(n) = min(h - 2) + min(h - 1) + 1</code></li></ul></li><li><p>Max number of Nodes required: <code>max(n) = 2^h - 1</code> (Sum of G-P Series with <code>a=1</code> and <code>r=2</code>)</p></li></ul></li><li><p>For <code>n</code> Nodes the:</p><ul><li>Min Height: <code>min(h) = log2 (n + 1)</code></li><li>Max Height: <code>max(h) = 1.44 log2 (n + 2)</code></li></ul></li><li><p>External Binary Nodes to Internal Binary Nodes: <code>e = i + 1</code></p></li></ul><h2 id="_2-3-trees" tabindex="-1">2 - 3 Trees <a class="header-anchor" href="#_2-3-trees" aria-label="Permalink to “2 - 3 Trees”">​</a></h2><ul><li><p>Multiway Search Tree (m-way)</p></li><li><p>Degree 3</p></li><li><p>Height Balanced Tree (B-tree)</p></li><li><p>All leaf nodes at same level</p></li><li><p>Every node must have <code>n/2</code> children</p></li><li><p>No duplicates</p></li><li><p>B Trees or B+ Trees</p></li><li><p>Used largely in DBMS</p></li></ul><h3 id="height-vs-nodes-of-2-3-trees" tabindex="-1">Height vs Nodes Of 2-3 Trees <a class="header-anchor" href="#height-vs-nodes-of-2-3-trees" aria-label="Permalink to “Height vs Nodes Of 2-3 Trees”">​</a></h3><ul><li><p>For Height <code>h</code> the if <code>h</code> starts from 1:</p><ul><li>Min number of Nodes required: <code>max(n) = 2^(h + 1) - 1</code></li><li>Max number of Nodes required: <code>max(n) = (3^(h + 1) - 1)/2</code></li></ul></li><li><p>For <code>n</code> Nodes the:</p><ul><li>Min Height: <code>min(h) = (log2 (n - 1)) - 1</code></li><li>Max Height: <code>max(h) = (log3 (2n + 1)) - 1</code></li></ul></li><li><p>External Binary Nodes to Internal Binary Nodes: <code>e = i + 1</code></p></li></ul><h2 id="_2-3-4-trees" tabindex="-1">2 - 3 - 4 Trees <a class="header-anchor" href="#_2-3-4-trees" aria-label="Permalink to “2 - 3 - 4 Trees”">​</a></h2><ul><li><p>B-Tree of degree = 4</p></li><li><p>Every node must have <code>n/2 = 4/2 = 2</code> children</p></li><li><p>All leaf at same level</p></li><li><p>Can be split as Left biased or Right biased if even number of keys are present</p></li></ul><h2 id="red-black-trees" tabindex="-1">Red - Black Trees <a class="header-anchor" href="#red-black-trees" aria-label="Permalink to “Red - Black Trees”">​</a></h2><ul><li><p>Its a height balanced Binary Search Tree</p></li><li><p>Every node is either <strong>Red</strong> or <strong>Black</strong></p></li><li><p>Root of a Tree is Black</p></li><li><p>NULL is also Black</p></li><li><p>Number of Blacks on Paths from Root to leaf are same</p></li><li><p>No 2 consecutive Red, Parent and Children of Red are Black</p></li><li><p>New Inserted Node is Red</p></li><li><p>Height in <code>log n &lt;= h &lt;= 2 * log n</code></p></li><li><p>Re-colour if Red-Red conflict where Parent and Uncle are Red</p></li><li><p>Do Zig-Zig (LL/RR) or Zig-Zag (LR/RL) Rotation if Red-Red conflict where Parent is Red and Uncle are Black</p></li></ul><h2 id="n-array-tree" tabindex="-1">N-Array Tree <a class="header-anchor" href="#n-array-tree" aria-label="Permalink to “N-Array Tree”">​</a></h2><h3 id="strict-n-array-tree" tabindex="-1">Strict N-Array Tree <a class="header-anchor" href="#strict-n-array-tree" aria-label="Permalink to “Strict N-Array Tree”">​</a></h3><h4 id="height-vs-nodes-of-strict-n-array-tree" tabindex="-1">Height vs Nodes Of Strict N-Array Tree <a class="header-anchor" href="#height-vs-nodes-of-strict-n-array-tree" aria-label="Permalink to “Height vs Nodes Of Strict N-Array Tree”">​</a></h4><ul><li><p>For Height <code>h</code> with degree <code>m</code> the:</p><ul><li>Min number of Nodes required: <code>min(n) = (m * h) + 1</code></li><li>Max number of Nodes required: <code>max(n) = (m^(h + 1) - 1)/(m - 1)</code> (Sum of G-P Series with <code>a=1</code> and <code>r=m</code>)</li></ul></li><li><p>For <code>n</code> Nodes with degree <code>m</code> the:</p><ul><li>Min Height: <code>min(h) = logm [n(m - 1) + 1] - 1</code></li><li>Max Height: <code>max(h) = (n - 1)/m</code></li></ul></li><li><p>External Binary Nodes to Internal Binary Nodes with degree <code>m</code>: <code>e = (m - 1)*i + 1</code></p></li></ul>`,53)]])}var s=r(a,[[`render`,o]]);export{i as __pageData,s as default};