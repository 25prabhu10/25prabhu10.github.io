import{A as e,d as t,m as n}from"./chunks/runtime-core.esm-bundler.BXAIOQQS.js";import{t as r}from"./chunks/plugin-vue_export-helper.CtN8rQnz.js";const i=JSON.parse(`{"title":"Key Words","description":"","frontmatter":{},"headers":[],"relativePath":"Concepts/Key_Words.md","filePath":"Concepts/Key_Words.md","lastUpdated":1756574703000}`);var a={name:`Concepts/Key_Words.md`};function o(r,i,a,o,s,c){return e(),t(`div`,null,[...i[0]||=[n(`<h1 id="key-words" tabindex="-1">Key Words <a class="header-anchor" href="#key-words" aria-label="Permalink to “Key Words”">​</a></h1><ol><li><p><strong>Predicate Functions</strong>: are functions that return a single TRUE or FALSE</p></li><li><p><strong>Turing Complete</strong>, <strong>Church-Turing Thesis</strong>: Something is &quot;computable&quot; if and only if it can be computed by a <strong>Turing machine</strong></p><ul><li>Conditional branching, as a result it should have the ability to jump (&quot;go to&quot;)</li><li>Arbitrary amount of memory (infinite RAM)</li></ul></li><li><p><strong>Race Condition</strong>: occurs when two or more threads can access shared data and they try to change it at the same time</p><ul><li><p>Because the thread scheduling algorithm can swap between threads at any time, you don&#39;t know the order in which the threads will attempt to access the shared data</p></li><li><p>Therefore, the result of the change in data is dependent on the thread scheduling algorithm, i.e. both threads are <strong>&quot;racing&quot; to access/change the data</strong></p></li><li><p>Pure functions can help in avoiding race condition issues</p></li></ul></li><li><p><strong>Adversity Paradox</strong>: The idea that we get stronger from stresses in our lives</p></li><li><p>The 5 o&#39;clock rule: The level of abstraction for solving a problem will bubble up until it allows the average developer to stop thinking about the problem</p></li><li><p>Working set overflow: The &quot;working set&quot; is short hand for &quot;parts of memory that the current algorithm is using&quot; and is determined by which parts of memory the CPU just happens to access</p></li><li><p>P95 Latency (P% Latency): The P95 Threshold indicates that 5% of transaction durations are greater than the threshold. For example, if the P95 threshold is 50 milliseconds, then 5% of transactions exceeded that threshold, taking longer than 50 milliseconds</p></li><li><p>Software Rot</p></li><li><p>Use-After-Free (UAF) is a vulnerability related to incorrect use of dynamic memory during program operation</p></li><li><p>Write-what-where Condition: Any condition where the attacker has the ability to write an arbitrary value to an arbitrary location, often as the result of a buffer overflow.</p></li><li><p>Global Offset Table (GOT): is a section of a computer program&#39;s (executables and shared libraries) memory used to enable computer program code compiled as an ELF file to run correctly, independent of the memory address where the program&#39;s code or data is loaded at runtime.</p></li><li><p>Convex hull</p></li></ol><p>Things to learn:</p><ul><li>Dynamic Programming</li><li>Bit Manipulation</li><li>Backtracking</li><li>Monotonic Stacks</li><li>Union Find</li><li>Tries</li><li>Prefix Sum</li><li>Topological Sort</li></ul><p>RAII (Resource acquisition is initialization)</p><h2 id="english-words" tabindex="-1">English Words <a class="header-anchor" href="#english-words" aria-label="Permalink to “English Words”">​</a></h2><ol><li><p><strong>Autological</strong> (adjective: <code>Au.to.log.i.cal</code>): Denoting any word which describes itself</p><p><em>Examples</em>:</p><ul><li><code>Poly.y.syl.lab.ic</code>: (of a word) having more than one syllable. It is Autological because it has more than one syllable (its own definition)</li><li>Pronounceable: A word which can be pronounced</li><li>Unhyphenated: A word which does not contain a hyphen</li><li>Noun: A word which is a person, place, thing, or idea</li></ul></li><li><p><strong>Heterological</strong> (adjective: <code>Het.er.o.log.i.cal</code>): Denoting any word which does not describe itself</p><ul><li>Opposite of Autological</li></ul><p><em>Examples</em>:</p><ul><li><code>Mon.o.syl.lab.ic</code>: (of a word) having only one syllable, but the word itself is polysyllabic</li></ul></li></ol><h2 id="the-grelling-nelson-paradox" tabindex="-1">The Grelling-Nelson Paradox <a class="header-anchor" href="#the-grelling-nelson-paradox" aria-label="Permalink to “The Grelling-Nelson Paradox”">​</a></h2><p>The Grelling-Nelson Paradox is a self-referential paradox that arises when one considers whether the word &quot;heterological&quot; is heterological. The word &quot;heterological&quot; is defined as a word that does not describe itself. If &quot;heterological&quot; is heterological, then it describes itself, which contradicts its own definition. If &quot;heterological&quot; is not heterological, then it does not describe itself, which means it is heterological. This paradox is similar to the liar paradox, which arises when one considers the sentence &quot;This statement is false.&quot;</p><ul><li>Kurt Grelling (1886-1942) and Leonard Nelson (1882-1927) were German philosophers</li></ul><p>For any given word &#39;X&#39;:</p><ul><li>The word &#39;X&#39; describes itself</li><li>The word &#39;X&#39; does not describe itself</li></ul><p>Using the <em>Principle of Bivalence</em>, the word &#39;X&#39; must either be Autological or Heterological</p><h2 id="the-liar-paradox" tabindex="-1">The Liar Paradox <a class="header-anchor" href="#the-liar-paradox" aria-label="Permalink to “The Liar Paradox”">​</a></h2><p>The Liar Paradox is a self-referential paradox that arises when one considers the sentence &quot;This statement is false.&quot; If the statement is true, then it must be false, which contradicts its own truth. If the statement is false, then it must be true, which contradicts its own falsity. This paradox highlights the challenges of self-reference and the limitations of language and logic</p><h2 id="semantic-versioning-semver" tabindex="-1">Semantic Versioning (SemVer) <a class="header-anchor" href="#semantic-versioning-semver" aria-label="Permalink to “Semantic Versioning (SemVer)”">​</a></h2><p><a href="https://semver.org/" target="_blank" rel="noreferrer">Semantic Versioning 2.0.0</a>: Under this scheme, version numbers and the way they change convey meaning about the underlying code and what has been modified from one version to the next</p><p>Given a version number <code>MAJOR.MINOR.PATCH</code>, increment the:</p><ol><li>MAJOR version when you make incompatible API changes</li><li>MINOR version when you add functionality in a backward compatible manner</li><li>PATCH version when you make backward compatible bug fixes</li></ol><p>Additional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format</p><ul><li>Caret (<code>^</code>): All minor and patches OK (<code>^1.x.x</code>)</li><li>Tilde (<code>~</code>): All patches only (<code>~1.5.x</code>)</li></ul><p>Not everyone follows SemVer:</p><ul><li>TypeScript does not strictly adhere to Semantic Versioning (SemVer) for its language updates</li></ul>`,23)]])}var s=r(a,[[`render`,o]]);export{i as __pageData,s as default};