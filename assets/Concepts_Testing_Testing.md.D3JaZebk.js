import{f as e,h as t,j as n,t as r}from"./chunks/plugin-vue_export-helper.Dz-VHcSB.js";const i=JSON.parse(`{"title":"Testing","description":"Testing in software development","frontmatter":{"title":"Testing","description":"Testing in software development","next":{"text":"Unit Testing","link":"./Unit_Testing.md"},"prev":{"text":"Concepts","link":".."}},"headers":[],"relativePath":"Concepts/Testing/Testing.md","filePath":"Concepts/Testing/Testing.md","lastUpdated":1767382134000}`);var a={name:`Concepts/Testing/Testing.md`};function o(r,i,a,o,s,c){return n(),e(`div`,null,[...i[0]||=[t(`<h1 id="testing" tabindex="-1">Testing <a class="header-anchor" href="#testing" aria-label="Permalink to “Testing”">​</a></h1><p><em>Tests</em> describe the expected behaviour of the application</p><p>Types of Tests:</p><ul><li><strong><a href="./Unit_Testing.html">Unit Testing</a></strong>: Writing tests that confirm an individual function or piece of code works</li><li><strong><a href="#functional-testing">Functional Testing</a></strong>: tests all functionality of app</li><li><strong><a href="#integration-testing">Integration Testing</a></strong>: Testing multiple units of together</li><li><strong><a href="#end-to-end-testing">End-To-End Testing (E2E)</a></strong>: Run app in simulated environment close to production</li><li><strong>Acceptance Testing (UAT)</strong>: test client or user&#39;s requirements</li><li><strong>Regression Testing</strong>: make sure new code does not break existing functionality</li><li><strong>Sanity or smoke test</strong>: Run few of most important test first to make sure the app is not on fire before testing rest of the test suite</li><li><strong>Performance Testing</strong>: tests that test performance characteristics</li><li><strong>Load Testing</strong>: Testing app under expected load</li><li><strong>Stress or failure-over testing</strong>: Testing app under extreme load</li><li><strong>Security Testing</strong>: Testing app for security vulnerabilities</li><li><strong>Usability (UI) Testing</strong>: Testing app for user-friendliness</li><li><strong>System Testing</strong>: Works on real hardware</li><li><strong>Fuzz Testing</strong>: Testing app with random data inputs</li></ul><h2 id="testing-methods-and-approaches" tabindex="-1">Testing Methods and Approaches <a class="header-anchor" href="#testing-methods-and-approaches" aria-label="Permalink to “Testing Methods and Approaches”">​</a></h2><p>Common Testing Approaches:</p><ol><li>Obvious implementation</li><li>Fake it till you make it</li><li>Triangulation</li></ol><p>Testing Methodologies:</p><ol><li><a href="#test-driven-development-tdd">Test-Driven Development</a></li><li><a href="#behaviour-driven-development-bdd">Behaviour Driven Development</a></li><li>Acceptance Test-Driven Development:</li></ol><h3 id="test-driven-development-tdd" tabindex="-1">Test-Driven Development (TDD) <a class="header-anchor" href="#test-driven-development-tdd" aria-label="Permalink to “Test-Driven Development (TDD)”">​</a></h3><p>TDD is software development process relying on software requirements being converted to test cases before software is fully developed, and tracking all software development by repeatedly testing the software against all test cases. This is as opposed to software being developed first and test cases created later</p><ul><li><strong>Refactoring</strong>: Improving the internal structure of your code without changing its external behaviour</li></ul><p>TDD cycle (<em>Test-Code-Refactor</em>):</p><ol><li>Add a test</li><li>Run all test. The new test <em>should fail</em> for expected reasons</li><li>Write the simplest code that passes the new test</li><li>All tests should now pass</li><li>Refactor as needed, using tests after each refactor to ensure that functionality is preserved</li><li>Repeat</li></ol><p>The above cycle of steps, which repeat over and over again are usually represented as:</p><div class="note custom-block github-alert"><p class="custom-block-title">TDD Cycle</p><p><strong>Red</strong> --&gt; <strong>Green</strong> --&gt; <strong>Refactor</strong> (Blue)</p></div><p>Advantages:</p><ul><li>Small test --&gt; modular apps</li><li>Refactor early, not late</li><li>Allows automated testing</li></ul><p>Disadvantages:</p><ul><li>Writing tests can be hard</li><li>Initially takes more time</li><li>Danger of constant refactoring</li></ul><h3 id="behaviour-driven-development-bdd" tabindex="-1">Behaviour Driven Development (BDD) <a class="header-anchor" href="#behaviour-driven-development-bdd" aria-label="Permalink to “Behaviour Driven Development (BDD)”">​</a></h3><p>BDD emerged from TDD</p><ul><li><p>In BDD, tests are written first as in TDD, but <strong>focuses on tests which describe behaviour</strong>, rather than tests which test a unit of implementation</p></li><li><p>The <strong>Given-When-Then</strong> approach is used for writing test cases:</p><ul><li><strong>Given</strong> the user has entered valid login credentials</li><li><strong>When</strong> a user clicks on the login button</li><li><strong>Then</strong> display the successful validation message</li></ul></li><li><p>BDD suggests that unit test names be whole sentences starting with a conditional verb (&quot;should&quot; in English for example)</p></li></ul><p>Benefits of BDD approach:</p><ul><li><p>Helps reach a wider audience by the usage of non-technical language</p></li><li><p>Focuses in how the system should behave from customer&#39;s and the developer&#39;s perspective</p></li><li><p>BDD is a cost-effective technique</p></li></ul><p>BDD is very explicitly defined:</p><ul><li><p>Involves collaboration between lots of roles</p><ul><li>Developers, QA, business partners, etc...</li></ul></li><li><p>Defines process for different groups to interact</p></li></ul><h2 id="integration-testing" tabindex="-1">Integration Testing <a class="header-anchor" href="#integration-testing" aria-label="Permalink to “Integration Testing”">​</a></h2><p>Integration Testing involves combining individual units of code or modules and testing them as a group</p><ul><li>Verify that different modules or services used by your application work well together</li><li><strong>Focus on interactions between modules</strong></li><li>Can involve testing with external systems (databases, APIs, etc.)</li><li>Can be done after unit testing and before functional or end-to-end testing</li></ul><h2 id="functional-testing" tabindex="-1">Functional Testing <a class="header-anchor" href="#functional-testing" aria-label="Permalink to “Functional Testing”">​</a></h2><p>Functional Testing involves testing the complete functionality of an application to ensure it meets the specified requirements</p><ul><li>Include all relevant units, test behaviour</li><li>Close to how users interact with software</li><li>Robust tests</li><li>Catch issues that unit tests might miss</li><li>Tests can be slower than unit tests</li><li>More difficult to debug failing tests</li></ul><h2 id="end-to-end-testing" tabindex="-1">End-To-End Testing <a class="header-anchor" href="#end-to-end-testing" aria-label="Permalink to “End-To-End Testing”">​</a></h2><p>End-to-End (E2E) Testing involves testing the entire application flow from start to finish to ensure that all components work together as expected</p><p>Tools for E2E testing for web applications:</p><ul><li><a href="https://playwright.dev/" target="_blank" rel="noreferrer">Playwright</a></li><li><a href="https://www.cypress.io/" target="_blank" rel="noreferrer">Cypress</a></li><li><a href="https://www.selenium.dev/" target="_blank" rel="noreferrer">Selenium</a></li><li><a href="https://pptr.dev/" target="_blank" rel="noreferrer">Puppeteer Library</a></li></ul>`,37)]])}var s=r(a,[[`render`,o]]);export{i as __pageData,s as default};