import{f as e,h as t,j as n,t as r}from"./chunks/plugin-vue_export-helper.Dz-VHcSB.js";const i=JSON.parse(`{"title":"Text Encoding","description":"An overview of text encoding methods, including ASCII, UTF-8, UTF-16, and their applications","frontmatter":{"title":"Text Encoding","description":"An overview of text encoding methods, including ASCII, UTF-8, UTF-16, and their applications"},"headers":[],"relativePath":"Concepts/Text_Encoding.md","filePath":"Concepts/Text_Encoding.md","lastUpdated":1766945700000}`);var a={name:`Concepts/Text_Encoding.md`};function o(r,i,a,o,s,c){return n(),e(`div`,null,[...i[0]||=[t(`<h1 id="text-encoding" tabindex="-1">Text Encoding <a class="header-anchor" href="#text-encoding" aria-label="Permalink to ‚ÄúText Encoding‚Äù">‚Äã</a></h1><p>Text encoding is the process of converting characters into a format that can be easily stored and transmitted by computers. Computers use binary code (0s and 1s) to represent data, so text must be encoded into binary for processing and storage</p><p>Various encoding methods have been developed over the years to accommodate the growing need for representing diverse characters and symbols from different languages and scripts</p><ul><li>EBCDIC</li><li>FIELDATA</li><li>Baudot Code</li><li>ITA2</li><li><a href="#ascii-encoding">ASCII (American Standard Code for Information Interchange)</a></li><li><a href="#unicode">UTF-8 (8-bit Unicode Transformation Format)</a>, UTF-16, and UTF-32</li></ul><h2 id="encoding" tabindex="-1">Encoding <a class="header-anchor" href="#encoding" aria-label="Permalink to ‚ÄúEncoding‚Äù">‚Äã</a></h2><p>The term <em>encoding</em> means the method in which characters are represented as a series of bytes</p><h2 id="ascii-encoding" tabindex="-1">ASCII Encoding <a class="header-anchor" href="#ascii-encoding" aria-label="Permalink to ‚ÄúASCII Encoding‚Äù">‚Äã</a></h2><p><strong>American Standard Code for Information Interchange</strong> (ASCII) (1963), is a character encoding standard for electronic communication</p><ul><li>It was originally based on the English alphabet</li><li>Each character is represented by a 7-bit fixed-width binary number <ul><li>Can encode only <strong>128 characters</strong> (<code>0000000</code> to <code>1111111</code>)</li></ul></li><li>It includes: <ul><li>Control characters (non-printable) such as carriage return, line feed, and tab etc. (first 32 characters)</li><li>Printable characters (letters, digits, punctuation marks, and a few special symbols)</li></ul></li><li>They used only 7 bits for ASCII, the 8th bit was used for error checking or as a parity bit</li></ul><p><em>Example:</em></p><ul><li>The capital letter <em>A</em> is represented as: <code>A: 65 = 41 (hex) = 1000001 (binary)</code></li><li>The small letter <em>a</em> is represented as:<code>a: 97 = 61 (hex) = 1100001 (binary)</code></li></ul><p><a href="https://en.wikipedia.org/wiki/ASCII#Printable_character_table" target="_blank" rel="noreferrer">Complete ASCII Table</a></p><p>ASCII is widely used still today in programming, data storage, and communication protocols. It has gone through several revisions and extensions to accommodate more characters and symbols, leading to the development of various character encoding standards such as ISO-8859 and Unicode</p><p>Limitations:</p><ul><li>Limited character set (only 128 characters)</li><li>Not suitable for representing characters from non-English languages</li></ul><h2 id="iso-8856-x" tabindex="-1">ISO-8856-X <a class="header-anchor" href="#iso-8856-x" aria-label="Permalink to ‚ÄúISO-8856-X‚Äù">‚Äã</a></h2><ul><li>ASCII compatible</li><li>Used 8-Bit encoding <ul><li>Can encode 256 characters (<code>00000000</code> to <code>11111111</code>)</li></ul></li><li>8859-2: (Central Europe)</li></ul><h2 id="unicode" tabindex="-1">Unicode <a class="header-anchor" href="#unicode" aria-label="Permalink to ‚ÄúUnicode‚Äù">‚Äã</a></h2><p><a href="https://www.unicode.org/versions/Unicode17.0.0/" target="_blank" rel="noreferrer">Unicode</a> (1988) is a <strong>universal character encoding standard</strong> that aims to provide a unique number for every character, regardless of the platform, program, or language</p><ul><li><p>Each character or symbol is mapped to a numerical value which is referred to as a <strong>code point</strong></p><ul><li>It&#39;s like a database which gives the relationship between a code point to a character</li></ul></li><li><p>Fully ASCII and ISO-8859 compatible</p></li><li><p>It uses variable width encoding aka MultiByte character set (MBCS) to represent characters</p><ul><li>Can use 1 to 4 bytes per character</li><li>First bit of the byte indicates whether it&#39;s a single-byte or multi-byte character, this allows for backward compatibility with ASCII (making use of 1 byte which was not used in ASCII) <ul><li><p>The first byte of a multi-byte character is known as the lead byte, and the subsequent bytes are known as trail or continuation bytes</p></li><li><p>All the single-byte characters start with <code>0</code> in the MSB</p></li><li><p>While multi-byte characters start with <code>1</code> in the MSB of the lead byte and <code>10</code> in the MSB of the trail bytes</p></li><li><p><code>0xxxxxxx</code>: Single-byte character (ASCII)</p></li><li><p><code>110xxxxx 10xxxxxx</code>: 2-byte character</p></li><li><p><code>1110xxxx 10xxxxxx 10xxxxxx</code>: 3-byte character</p></li></ul></li></ul></li></ul><p>This is called UTF-8 encoding (8-bit Unicode Transformation Format), as it uses 8-bit blocks to represent a character</p><ul><li>Almost all modern systems and applications support and use UTF-8 encoding</li><li>If a file is encoded in UTF-8, it should be opened and read using UTF-8 encoding to ensure that the characters are interpreted correctly</li></ul><p>We can use 16-bit or 32-bit blocks to represent characters as well, known as UTF-16 and UTF-32 respectively</p><ul><li>Windows internally uses UTF-16 encoding for representing text</li></ul><h3 id="code-points" tabindex="-1">Code Points <a class="header-anchor" href="#code-points" aria-label="Permalink to ‚ÄúCode Points‚Äù">‚Äã</a></h3><ul><li><p>Current version: 17 (~159,801 characters and 172 scripts) as of Oct 2025</p></li><li><p><code>U+0000</code> - <code>U+10FFFF</code></p></li><li><p><code>U+0000</code> - <code>U+007F</code>: ASCII</p></li><li><p><code>U+0080</code> - <code>U+00FF</code>: ISO</p></li><li><p><code>U+0000</code> - <code>U+FFFF</code> (BMP: Basic Multilingual Plane) = 65536 characters</p></li><li><p><code>U+010000</code> - <code>U+10FFFF</code> (Astral Planes) = Over a million</p></li></ul><p>There are code points such as <code>C0</code>, <code>C1</code>, and <code>F5</code> to <code>FF</code> which are <strong>not valid</strong> in UTF-8 encoding, if encountered, they are deemed as invalid or malformed sequences and a replacement character (<code>ÔøΩ</code> - <code>FFBFBD</code>) is used instead as suggested by Unicode standard</p><p>Special Code Points:</p><ul><li><p>Zero-Width Joiner (ZWJ - <code>U+200D</code>) and Zero-Width Non-Joiner (ZWNJ - <code>U+200C</code>)</p><ul><li>These are invisible characters that affect the rendering of adjacent characters without adding any visible space</li><li>Used in scripts like Arabic and Indic to control the joining behaviour of characters</li><li>Emoji sequences also use ZWJ to create complex emoji by combining multiple characters like the family emoji <code>üë®‚Äçüë©‚Äçüëß‚Äçüë¶</code>. They are known as <em>grapheme cluster</em></li></ul></li><li><p><code>U+FEFF</code>: Byte Order Mark (BOM)</p><ul><li>Used to indicate the endianness of a text file or stream</li><li>Can also be used to signal that a file is encoded in UTF-8</li></ul></li><li><p><code>U+FFFD</code>: Replacement Character</p><ul><li>Used to replace an unknown, unrecognised, or unrepresentable character</li></ul></li></ul><h3 id="normalization" tabindex="-1">Normalization <a class="header-anchor" href="#normalization" aria-label="Permalink to ‚ÄúNormalization‚Äù">‚Äã</a></h3><p>Normalization is the process of converting text to a standard form, ensuring that characters that may have multiple representations are treated as equivalent for comparison and searching purposes</p><ul><li>For example, the character <code>√©</code> can be represented as a single code point (<code>U+00E9</code>) or as a combination of the letter <code>e</code> (<code>U+0065</code>) and an acute accent (<code>U+0301</code>)</li></ul><p>Normalization <strong>ensures two strings that may use a different binary representation for their characters have the same binary value after normalization</strong></p><ul><li>Normalisation algorithms must be idempotent (applying it multiple times has the same effect as applying it once)</li><li>Convert strings to canonical form so that it is standardised</li></ul><p>There are two overall types of equivalence between characters:</p><ol><li><p><em>Canonical Equivalence:</em> characters are assumed to have the same appearance and meaning when printed or displayed</p></li><li><p><em>Compatibility Equivalence:</em> is a weaker equivalence, in that two values may represent the same abstract character but can be displayed differently</p></li></ol><p>There are 4 Normalization algorithms defined by the Unicode standard:</p><ol><li><p><strong>NFD</strong>: <em>Normalization Form Canonical Decomposition</em>: Characters are decomposed by canonical equivalence, and multiple combining characters are arranged in a specific order</p></li><li><p><strong>NFC</strong>: <em>Normalization Form Canonical Composition</em>: Characters are decomposed and then recomposed by canonical equivalence</p></li><li><p><strong>NFKD</strong>: <em>Normalization Form Compatibility Decomposition</em>: Characters are decomposed by compatibility, and multiple combining characters are arranged in a specific order</p></li><li><p><strong>NFKC</strong>: <em>Normalization Form Compatibility Composition</em>: Characters are decomposed by compatibility, then recomposed by canonical equivalence</p></li></ol>`,38)]])}var s=r(a,[[`render`,o]]);export{i as __pageData,s as default};