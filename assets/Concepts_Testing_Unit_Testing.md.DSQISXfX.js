import{f as e,h as t,j as n,t as r}from"./chunks/plugin-vue_export-helper.Dz-VHcSB.js";const i=JSON.parse(`{"title":"Unit Testing","description":"Unit Testing is the practice of testing individual units or components of a software application in isolation to ensure they function as intended","frontmatter":{"title":"Unit Testing","description":"Unit Testing is the practice of testing individual units or components of a software application in isolation to ensure they function as intended"},"headers":[],"relativePath":"Concepts/Testing/Unit_Testing.md","filePath":"Concepts/Testing/Unit_Testing.md","lastUpdated":1769745554000}`);var a={name:`Concepts/Testing/Unit_Testing.md`};function o(r,i,a,o,s,c){return n(),e(`div`,null,[...i[0]||=[t(`<h1 id="unit-testing" tabindex="-1">Unit Testing <a class="header-anchor" href="#unit-testing" aria-label="Permalink to “Unit Testing”">​</a></h1><p><em>Unit test:</em> Test(s) written for testing a <em>unit</em> of code in isolation</p><p>Verify that <strong>a known, fixed input produces a known, fixed output</strong></p><ul><li>Testing a unit of work</li><li>An unit can be a method</li><li><a href="./Testing.html#test-driven-development-tdd">Red-green testing</a></li><li>System under test (SUT)</li><li><a href="#code-coverage">Code coverage</a></li><li>One <em>unit test</em> runs independently of any other unit test</li><li>Tests can (and do) run in any order</li><li>Tests can (and do) run in parallel in multiple threads</li><li><em>External dependencies</em> are managed with <a href="#test-doubles">Test Doubles</a> (such as <strong>Mocks/Stubs/Fakes</strong>)</li><li>A single unit test should run in a second or less</li><li>Unit test usually are partitioned into: Arrange, Act, Assert</li></ul><p>Unit tests should not be the only means to test an application, as:</p><ul><li>They are further away from how users interact with software</li><li>More likely to break with refactoring</li></ul><h2 id="characteristics-of-a-good-unit-test" tabindex="-1">Characteristics of a good unit test <a class="header-anchor" href="#characteristics-of-a-good-unit-test" aria-label="Permalink to “Characteristics of a good unit test”">​</a></h2><ul><li><p><strong>Fast</strong>: It is not uncommon for mature projects to have thousands of unit tests. Unit tests should take very little time to run (in <em>milliseconds</em>)</p></li><li><p><strong>Isolated</strong>: Unit tests are stand-alone, can be run in isolation, and have no dependencies on any outside factors such as a file system or database</p><ul><li>Mock dependencies</li><li>Test internals</li></ul></li><li><p><strong>Repeatable</strong>: Running a unit test should be consistent with its results, that is, it always returns the same result if you do not change anything in between runs</p></li><li><p><strong>Self-Checking</strong>:. The test should be able to automatically detect if it passed or failed without any human interaction</p></li><li><p><strong>Timely</strong>: A unit test should not take a disproportionately long time to write compared to the code being tested. If you find testing the code taking a large amount of time compared to writing the code, consider a design that is more testable</p></li></ul><p>Unit testing tips:</p><ul><li>Do not unit test everything</li><li>Use data that is close to production data</li><li>Cover edge cases</li><li>Write tests that are independent of each other</li></ul><h2 id="unit-test-structure" tabindex="-1">Unit Test Structure <a class="header-anchor" href="#unit-test-structure" aria-label="Permalink to “Unit Test Structure”">​</a></h2><ol><li><p><strong>Setup</strong>: Put the Unit Under Test (UUT) or the overall test system in the state needed to run the test</p></li><li><p><strong>Execution</strong>: Trigger/drive the UUT to perform the target behaviour and capture all output, such as return values and output parameters. This step is usually very simple</p></li><li><p><strong>Validation</strong>: Ensure the results of the test are correct. These results may include explicit outputs captured during execution or state changes in the UUT</p></li><li><p><strong>Clean-up</strong>: Restore UUT or the overall test system to the pre-test state. This restoration permits another test to execute immediately after this one. In some cases in order to preserve the information for possible test failure analysis the clean-up should be starting the test just before the test&#39;s setup run</p></li></ol><p>Arranging your tests: <strong>Arrange, Act, Assert</strong> is a common pattern when unit testing. As the name implies, it consists of three main actions:</p><ul><li><p><em>Arrange</em> your objects, creating and setting them up as necessary</p></li><li><p><em>Act</em> on an object</p></li><li><p><em>Assert</em> that something is as expected</p></li></ul><h2 id="naming-conventions" tabindex="-1">Naming conventions <a class="header-anchor" href="#naming-conventions" aria-label="Permalink to “Naming conventions”">​</a></h2><ul><li>Roy Osherove&#39;s naming strategy for unit tests: <code>[UnitOfWork_StateUnderTest_ExpectedBehaviour]</code><ul><li>E.g. <code>Divide_PositiveNumbers_ReturnsPositiveQuotient</code></li></ul></li></ul><h2 id="code-coverage" tabindex="-1">Code Coverage <a class="header-anchor" href="#code-coverage" aria-label="Permalink to “Code Coverage”">​</a></h2><p>A high code coverage percentage is often associated with a higher quality of code</p><p>Tools:</p><ul><li><p><a href="https://github.com/coverlet-coverage/coverlet" target="_blank" rel="noreferrer">Coverlet</a>: Code coverage framework</p></li><li><p><a href="https://github.com/danielpalme/ReportGenerator" target="_blank" rel="noreferrer">ReportGenerator</a>: Report generator</p></li></ul><h2 id="test-doubles" tabindex="-1">Test Doubles <a class="header-anchor" href="#test-doubles" aria-label="Permalink to “Test Doubles”">​</a></h2><p>A Test Double is an object that can stand-in for a real object in a test. Used instead of External Dependencies</p><ul><li>DB, Web, API, Library, Network etc...</li><li>If tests fail then it must due the unit of code that is being tested not due to its dependencies</li><li>Easy to simulate various scenarios</li></ul><p>Types of Test Doubles:</p><ol><li><p><strong>Dummy</strong>: A dummy is the simplest form of a test double. It facilitates linker time substitution by providing a default return value where required</p><ul><li>It is used as a placeholder when an argument needs to be filled in</li><li>Objects that the SUT (System Under Test) depends but they are never used</li><li>Not relevant to the test scope</li></ul></li><li><p><strong>Stub</strong>: Generates predefined outputs. It provides fake data to the SUT</p><ul><li>A stub is a controllable replacement for an existing dependency (or collaborator) in the system. By using a stub, you can test your code without dealing with the dependency directly</li><li>Programmed Stub to return a Success, Failure or Exception</li><li>A stub adds simplistic logic to a dummy, providing different outputs</li></ul></li><li><p><strong>Spy</strong>: It records information about how the class is being used</p></li><li><p><strong>Mock</strong>: Mocks replace external interface</p><ul><li>A mock object is a fake object in the system that decides whether or not a unit test has passed or failed. A mock starts out as a Fake until it&#39;s <strong>asserted</strong> against</li><li>They have the same signature of the function</li><li>We can check if the function is being called or not</li><li>How many times is the function being called?</li><li>What Parameters are passed when it is called?</li><li>It defines an expectation of how it will be used. It will cause a failure if the expectation isn&#39;t met</li><li><strong>Right call, Right Number of times with Right set of Parameter and in the Right order</strong></li></ul></li><li><p><strong>Fake</strong>: Almost working implementation. It is an actual implementation of the contract but is unsuitable for production</p><ul><li>Connect to a local HTTP server</li><li>Instead of actually going to the internet it connects to a local (limited) implementation</li><li>Check the behaviour with respect to the actual data it receives from the server</li><li>A Fake can be a stub or a mock object</li></ul></li></ol><h2 id="tools" tabindex="-1">Tools <a class="header-anchor" href="#tools" aria-label="Permalink to “Tools”">​</a></h2><ol><li>Test Runners: <ul><li>Find tests</li><li>Run tests</li><li>Determine whether tests pass or fail</li><li>Code becomes DRY</li><li>Test results</li><li>Predictable</li><li>CI Integration</li><li>Auto Run</li><li><a href="https://github.com/avajs/ava" target="_blank" rel="noreferrer">AVA</a></li></ul></li></ol><h2 id="references" tabindex="-1">References <a class="header-anchor" href="#references" aria-label="Permalink to “References”">​</a></h2><ul><li><a href="https://www.youtube.com/watch?v=fr1E9aVnBxw" target="_blank" rel="noreferrer">Effective Unit Testing by Eliotte Rusty Harold</a></li></ul>`,29)]])}var s=r(a,[[`render`,o]]);export{i as __pageData,s as default};