import{f as e,h as t,j as n,t as r}from"./chunks/plugin-vue_export-helper.Dz-VHcSB.js";const i=JSON.parse(`{"title":"Microservices","description":"An architectural style of small, independent services to build large applications","frontmatter":{"title":"Microservices","description":"An architectural style of small, independent services to build large applications"},"headers":[],"relativePath":"Concepts/Designs/System_Designs/Microservices.md","filePath":"Concepts/Designs/System_Designs/Microservices.md","lastUpdated":1766945700000}`);var a={name:`Concepts/Designs/System_Designs/Microservices.md`};function o(r,i,a,o,s,c){return n(),e(`div`,null,[...i[0]||=[t(`<h1 id="microservices" tabindex="-1">Microservices <a class="header-anchor" href="#microservices" aria-label="Permalink to “Microservices”">​</a></h1><p>Microservices is an architectural style for building applications as a collection of small, independent services. Imagine it like a large, complex machine being broken down into smaller, specialized tools that work together</p><h2 id="principles-of-microservices" tabindex="-1">Principles of Microservices <a class="header-anchor" href="#principles-of-microservices" aria-label="Permalink to “Principles of Microservices”">​</a></h2><ul><li><strong>Independent and Autonomous</strong>: Each microservice should be self-contained and operate independently. This means they have their codebase, database, and business logic</li><li><strong>Loose Coupling</strong>: Microservices should rely as little as possible on each other. They communicate through well-defined APIs (Application Programming Interfaces) instead of being tightly interwoven</li><li><strong>Small and Focused</strong>: Microservices are designed to be small and focused on a single function. This makes them easier to understand, develop, test, and deploy</li><li><strong>Technology Agnostic</strong>: Microservices can be built with different programming languages and technologies, allowing developers to choose the best tool for the job</li><li><strong>Discoverable</strong>: Microservices need to be discoverable by other services in the system. This is often achieved through <strong>service registries</strong></li></ul><p>Following these principles allows for the following:</p><ul><li><strong>Faster Development and Deployment</strong>: Changes to one microservice can be made and deployed independently without affecting the entire application</li><li><strong>Scalability</strong>: Different application parts can be scaled up or down independently based on their needs</li><li><strong>Increased Fault Tolerance</strong>: If one microservice fails, it should not bring down the entire application</li><li><strong>Improved Maintainability</strong>: Smaller, focused services are easier to understand and maintain</li></ul><h2 id="microservices-vs-monolithic-architecture" tabindex="-1">Microservices vs. Monolithic Architecture <a class="header-anchor" href="#microservices-vs-monolithic-architecture" aria-label="Permalink to “Microservices vs. Monolithic Architecture”">​</a></h2><p>Meanwhile, in monolithic architecture, a single, self-contained application, all the functionalities are tightly coupled within one unit:</p><ul><li>All components are part of a single unit</li><li>Everything is developed, deployed, and scaled as 1 unit</li><li>App usually must be written with one tech stack</li><li>Teams need to be careful not to affect each other&#39;s work</li><li>Single artifact, hence redeploy the entire application on each update</li></ul><p>Key differences between monolithic and microservices architectures:</p><table tabindex="0"><thead><tr><th></th><th>Monolithic</th><th>Microservices</th></tr></thead><tbody><tr><td>Structure</td><td><strong>Single, unified codebase</strong> for the entire application</td><td>Collection of small, <strong>independent services</strong></td></tr><tr><td>Deployment</td><td>The entire application needs to be <strong>deployed together</strong></td><td>Services can be <strong>deployed independently</strong></td></tr><tr><td>Scalability</td><td>Scaling the entire application can be complex</td><td>Individual services can be scaled independently</td></tr><tr><td>Development</td><td>Changes require modifications to the entire codebase</td><td>Changes can be made to individual services</td></tr><tr><td>Complexity</td><td><strong>Simpler to understand</strong> and manage for small applications</td><td>These can be more <strong>complex to manage</strong> due to their distributed nature</td></tr></tbody></table><ul><li>Choosing the right approach depends on factors like the size and complexity of the application</li></ul><h2 id="challenges-of-microservices" tabindex="-1">Challenges of Microservices <a class="header-anchor" href="#challenges-of-microservices" aria-label="Permalink to “Challenges of Microservices”">​</a></h2><ul><li><strong>Increased Complexity</strong>: Managing many independent services can be more complex than a single monolithic codebase. This includes distributed tracing, monitoring, and configuration management</li><li><strong>Distributed Data Management</strong>: Data consistency across services can be tricky. Techniques like CQRS (Command Query Responsibility Segregation) and Event Sourcing can help</li><li><strong>Debugging and Monitoring</strong>: Troubleshooting issues become more complex as requests flow across multiple services. Distributed tracing tools are essential</li><li><strong>Integration Challenges</strong>: Microservices need to communicate effectively through APIs. Defining and maintaining stable APIs requires ongoing effort</li><li><strong>Development Team Culture</strong>: Microservices thrive with a DevOps culture that encourages collaboration and independent ownership</li><li><strong>Potential for Redundancy</strong>: Duplication of functionality across services can occur if not carefully planned</li></ul><p>While these challenges exist, with careful planning and tooling, microservices can be a powerful way to build scalable and maintainable applications</p><div class="language-text"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes vitesse-dark github-light" style="--shiki-dark:#dbd7caee;--shiki-light:#24292e;--shiki-dark-bg:#121212;--shiki-light-bg:#fff;" tabindex="0" dir="ltr"><code><span class="line"><span>The Options</span></span>
<span class="line"><span></span></span>
<span class="line"><span>             ^</span></span>
<span class="line"><span>             |</span></span>
<span class="line"><span>             | Distributed BBoM           Microservices</span></span>
<span class="line"><span>             |</span></span>
<span class="line"><span>Distribution |</span></span>
<span class="line"><span>             |</span></span>
<span class="line"><span>             | Big Ball of Mud (BBoM)     Modular Monolith</span></span>
<span class="line"><span>             |</span></span>
<span class="line"><span>              -----------------------------------------------&gt;</span></span>
<span class="line"><span>                               Modularisation</span></span></code></pre></div><h2 id="service-registry" tabindex="-1">Service Registry <a class="header-anchor" href="#service-registry" aria-label="Permalink to “Service Registry”">​</a></h2><p>How applications and services locate each other</p><h2 id="load-balancer" tabindex="-1">Load Balancer <a class="header-anchor" href="#load-balancer" aria-label="Permalink to “Load Balancer”">​</a></h2><p>Efficiently distributes network traffic across a group of backend services</p><h2 id="circuit-breaker" tabindex="-1">Circuit Breaker <a class="header-anchor" href="#circuit-breaker" aria-label="Permalink to “Circuit Breaker”">​</a></h2><p>Stops an application from performing an operation that is likely to fail</p><h2 id="api-gateway" tabindex="-1">API Gateway <a class="header-anchor" href="#api-gateway" aria-label="Permalink to “API Gateway”">​</a></h2><p>A server that is the single entry point into the system</p><h2 id="external-configuration" tabindex="-1">External Configuration <a class="header-anchor" href="#external-configuration" aria-label="Permalink to “External Configuration”">​</a></h2><p>Keeps the configuration information in a centralized external store</p><h2 id="bounded-context" tabindex="-1">Bounded Context <a class="header-anchor" href="#bounded-context" aria-label="Permalink to “Bounded Context”">​</a></h2><p>The boundary of a model that represents its concepts, relationships, and rules</p><h2 id="design-patterns-for-microservices" tabindex="-1">Design Patterns for Microservices <a class="header-anchor" href="#design-patterns-for-microservices" aria-label="Permalink to “Design Patterns for Microservices”">​</a></h2><ol><li><p><strong>Shared Database Pattern</strong> (anti-pattern): Multiple microservices share the same database schema, which can lead to tight coupling and deadlocks in DBMS</p></li><li><p><strong>The Database-per-Service Pattern</strong>: Each microservice has its own database to ensure loose coupling and independent data management</p><ul><li>Issue arise when a business transaction spans multiple services, leading to data consistency challenges. For example, updating an order and its associated inventory in separate services may result in one update succeeding while the other fails</li><li>Solutions include using eventual consistency, <strong>sagas</strong>, or <strong>two-phase</strong> commits</li></ul></li><li><p><strong>The Saga Pattern</strong>: Manages distributed transactions across multiple microservices using a series of compensating actions</p><ul><li>Two types of sagas: <ul><li><strong>Choreography-based Sagas</strong>: Each service involved in the saga publishes events that trigger actions in other services. Message brokers like Kafka or RabbitMQ are often used to facilitate this communication</li><li><strong>Orchestration-based Sagas</strong>: A central orchestrator service coordinates the saga by sending commands to the participating services</li></ul></li></ul></li><li><p><strong><a href="./CQRS.html">CQRS (Command Query Responsibility Segregation) Pattern</a></strong>: Separates read and write operations into different models to optimize performance and scalability</p></li><li><p><strong>The Event Sourcing Pattern</strong>: Instead of storing the current state, store a sequence of events that led to the current state</p></li><li><p><strong>The API Gateway Pattern</strong>: A single entry point for all client requests, routing them to the appropriate microservices</p></li><li><p><strong>The Circuit Breaker Pattern</strong>: Prevents a service from repeatedly trying to execute an operation that is likely to fail</p></li><li><p><strong>The Sidecar Pattern</strong>: Deploys helper components alongside the main service to provide additional functionality like logging, monitoring, or configuration</p></li><li><p><strong>The Strangler Fig Pattern</strong>: Gradually replaces parts of a monolithic application with microservices over time</p></li></ol><h2 id="references" tabindex="-1">References <a class="header-anchor" href="#references" aria-label="Permalink to “References”">​</a></h2><ul><li><a href="https://redis.com/blog/5-microservices-misconceptions/?utm_source=marketo&amp;utm_medium=email&amp;utm_campaign=March_2023_newsletter&amp;mkt_tok=OTE1LU5GRC0xMjgAAAGKjJhaOSj_kmp5uYNVRxI3cr5ViVBgiFI6mr87hD69pBGwrwvDbZzEzlmO7XbYqcbrEQ-w2Wm6NOHSinzvW8YwguMCP8kupyLp48LE4VIZH43xzdc" target="_blank" rel="noreferrer">5 Microservices Misconceptions</a></li></ul>`,32)]])}var s=r(a,[[`render`,o]]);export{i as __pageData,s as default};